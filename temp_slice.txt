115	        super.defineSynchedData();
116	        this.entityData.define(ABDUCTING, Boolean.FALSE);
117	        this.entityData.define(GLOW_ENABLED, Boolean.FALSE);
118	    }
119	
120	    @Override
121	    public void tick() {
122	        super.tick();
123	        if (jumpCooldown > 0) jumpCooldown--;
124	        if (abductionCooldown > 0) abductionCooldown--;
125	        if (revWobbleLeft > 0) revWobbleLeft--;
126	
127	        // No server-side pilot teleport during possession; camera is set to saucer entity client-side
128	
129	        if (!level().isClientSide && boostTicks > 0) {
130	            // Authoritative server movement: step exactly along the beam path every tick (no particles)
131	            Vec3 step = this.boostStep;
132	            double spd = step.length();
133	            if (spd > ABS_SPEED_CAP) step = step.scale(ABS_SPEED_CAP / spd);
134	
135	            double nx = this.getX() + step.x;
136	            double ny = this.getY() + step.y;
137	            double nz = this.getZ() + step.z;
138	
139	            this.absMoveTo(nx, ny, nz);
140	            this.setDeltaMovement(step);
141	            this.hasImpulse = true;
142	            this.setOnGround(false);
143	            this.fallDistance = 0;
144	
145	            boostTicks--;
146	            if (boostTicks <= 0 && this.noClipBurn) {
147	                this.noPhysics = false;
148	                this.noClipBurn = false;
149	            }
150	        }
151	
152	        // Server: handle confirmation glow blinking
153	        if (!level().isClientSide) {
154	            processConfirmBlink();
155	        }
156	
157	        // (abduction beam rendered by renderer)
158	
159	        if (!level().isClientSide) {
160	            spawnGroundScuffsAtAnyAltitudeUpTo20();
161	        } else {
162	            // Client-side: subtle ground particles where the abduction beam meets the ground
163	            if (this.isAbductionActive() && this.tickCount % 3 == 0) {
164	                double gy = groundYAt(this.getX(), this.getZ()) + 0.05;
165	                if (gy > this.level().getMinBuildHeight()) {
166	                    int pts = 10;
167	                    double time = this.tickCount * 0.15;
168	                    for (int i = 0; i < pts; i++) {
169	                        double a = time + (i * (Math.PI * 2.0 / pts));
170	                        double rad = ABDUCT_RADIUS * (0.85 + this.getRandom().nextDouble() * 0.20);
171	                        double px = this.getX() + Math.cos(a) * rad;
172	                        double pz = this.getZ() + Math.sin(a) * rad;
173	                        this.level().addParticle(new DustParticleOptions(new org.joml.Vector3f(0.20f, 0.95f, 0.85f), 0.9f),
174	                                px, gy, pz, 0.0, 0.0, 0.0);
175	                    }
176	                }
177	            }
178	            // Client-side: cooldown steam emission while jump is recharging
179	            if (this.jumpCooldown > 0 && JUMP_COOLDOWN_TICKS > 0) {
180	                double frac = this.jumpCooldown / (double) JUMP_COOLDOWN_TICKS; // 1->0
181	                int count = 2 + (int) Math.ceil(6 * frac);
182	                double r = 0.8;
183	                for (int i = 0; i < count; i++) {
184	                    double ang = this.getRandom().nextDouble() * Math.PI * 2.0;
185	                    double rad = r * (0.5 + this.getRandom().nextDouble() * 0.8);
186	                    double px = this.getX() + Math.cos(ang) * rad;
187	                    double pz = this.getZ() + Math.sin(ang) * rad;
188	                    double py = this.getY() + 0.6 + this.getRandom().nextDouble() * 0.5;
189	                    double vy = 0.03 + this.getRandom().nextDouble() * 0.04;
190	                    double vx = (this.getRandom().nextDouble() - 0.5) * 0.02;
191	                    double vz = (this.getRandom().nextDouble() - 0.5) * 0.02;
192	                    this.level().addParticle(ParticleTypes.CLOUD, px, py, pz, vx, vy, vz);
193	                }
194	            }
195	        }
196	    }
197	
198	    @Override
199	    protected void doPush(Entity e) {
200	    }
201	
202	    @Override
203	    public boolean canBeCollidedWith() {
204	        return true;
205	    }
206	
207	    @Override
208	    public boolean isPickable() {
209	        return true;
210	    }
211	
212	    @Override
213	    protected InteractionResult mobInteract(Player player, InteractionHand hand) {
214	        if (this.level().isClientSide) return InteractionResult.SUCCESS;
215	        if (player instanceof net.minecraft.server.level.ServerPlayer sp) {
216	            // Toggle piloting on right-click
217	            if (this.pilotId == sp.getId()) {
218	                this.stopPiloting();
219	            } else {
220	                this.startPiloting(sp);
221	            }
222	        }
223	        return InteractionResult.CONSUME;
224	    }
225	
226	    @Override
227	    public double getPassengersRidingOffset() {
228	        return Math.max(0.5D, this.getBbHeight() * 0.5D);
229	    }
230	
231	    @Override
232	    @Nullable
233	    public LivingEntity getControllingPassenger() {
234	        return null;
235	    }
236	
237	    @Override
238	    public boolean canJump() {
239	        return this.jumpCooldown == 0;
240	    }
241	
242	    @Override
243	    public int getJumpCooldown() {
244	        return jumpCooldown;
245	    }
246	
247	    // --- Piloting state (server authoritative) ---
248	    private int pilotId = -1;
249	
250	    private void startPiloting(net.minecraft.server.level.ServerPlayer sp) {
251	        this.pilotId = sp.getId();
252	        sp.noPhysics = true;
253	        sp.setInvisible(true);
254	        sp.setInvulnerable(true);
255	        sp.fallDistance = 0f;
256	        com.exoticmatter.totm.network.ModNetwork.CHANNEL.sendTo(new com.exoticmatter.totm.network.packet.PilotStartS2CPacket(this.getId()), sp.connection.connection, net.minecraftforge.network.NetworkDirection.PLAY_TO_CLIENT);
257	    }
258	
259	    private void stopPiloting() {
260	        if (!(this.level() instanceof net.minecraft.server.level.ServerLevel sl)) return;
261	        if (pilotId == -1) return;
262	        var e = sl.getEntity(pilotId);
263	        if (e instanceof net.minecraft.server.level.ServerPlayer sp) {
264	            // Place player at the saucer on exit
265	            sp.teleportTo(this.getX(), this.getY() + this.getPassengersRidingOffset(), this.getZ());
266	            // Prevent fall damage immediately after dismount (especially at ~4 blocks)
267	            sp.fallDistance = 0f;
268	            double groundY = groundYAt(this.getX(), this.getZ());
269	            double alt = (this.getY() + this.getPassengersRidingOffset()) - groundY;
270	            if (alt <= 5.0) {
271	                sp.getPersistentData().putLong("totm_no_fall_until", sl.getGameTime() + 40L);
272	            }
273	            sp.noPhysics = false;
274	            sp.setInvisible(false);
275	            sp.setInvulnerable(false);
276	            com.exoticmatter.totm.network.ModNetwork.CHANNEL.sendTo(new com.exoticmatter.totm.network.packet.PilotStopS2CPacket(), sp.connection.connection, net.minecraftforge.network.NetworkDirection.PLAY_TO_CLIENT);
277	        }
278	        pilotId = -1;
279	    }
280	
281	    private net.minecraft.server.level.ServerPlayer getPilot() {
282	        if (pilotId == -1 || !(this.level() instanceof net.minecraft.server.level.ServerLevel sl)) return null;
283	        var e = sl.getEntity(pilotId);
284	        return (e instanceof net.minecraft.server.level.ServerPlayer sp) ? sp : null;
285	    }
286	
287	    @Override
288	    public void handleStartJump(int power) {
289	        if (!level().isClientSide) return;
290	
291	        clientLastJumpPower = power;
292	        revWobbleLeft = Math.min(revWobbleLeft + 1, REV_WOBBLE_TICKS);
293	        var mc = Minecraft.getInstance();
294	        if (mc.player != null && mc.player.getVehicle() == this) {
295	            // no debug text or particles
296	        }
297	
298	        // (abduction visuals handled during tick for smoother motion)
299	    }
300	
301	    @Override
302	    public void handleStopJump() {
303	        // No-op; the engine reports final power through onPlayerJump
304	    }
305	
306	    @Override
307	    public void onPlayerJump(int power) {
308	        if (!level().isClientSide) {
309	            LivingEntity rider = this.getControllingPassenger();
310	            Vec3 dir = null;
311	            if (rider != null) {
312	                Vec3 look = rider.getViewVector(1.0F);
313	                dir = look.normalize(); // include vertical to allow aiming up/down
314	            }
315	            if (dir == null || dir.lengthSqr() < 1.0e-6) {
316	                Vec3 fallback = Vec3.directionFromRotation(this.getXRot(), this.getYRot());
317	                dir = fallback.normalize();
318	            }
319	
320	            applySlingshotServer(power, dir);
321	            return;
322	        }
323	
324	        // Client: send jump to server with the resolved final power
325	        ModNetwork.sendToServer(new SaucerJumpPacket(this.getId(), power));
326	
327	        revWobbleLeft = REV_WOBBLE_TICKS;
328	        var mc = Minecraft.getInstance();
329	        if (mc.player != null && mc.player.getVehicle() == this) {
330	            // no debug text or sounds
331	        }
332	    }
333	
334	    // Server-side application of launch
335	    public void applySlingshotServer(int power, Vec3 dashDirFromPacket) {
336	        if (!this.isAlive()) return;
337	        // Respect cooldown and avoid overlapping burns
338	        if (this.jumpCooldown > 0 || this.boostTicks > 0) return;
339	
340	        int pwr = Mth.clamp(power, 1, 100);
341	        double t = pwr / 100.0;
342	        double eased = t * t;
343	
344	        // Distance and duration scale with charge (proportional feel)
345	        int ticks = (int) Math.round(Mth.lerp(eased, BURN_TICKS_MIN, BURN_TICKS_MAX));
346	        double dist = Mth.lerp(eased, DIST_MIN, DIST_MAX);
347	        double speed = dist / Math.max(1, ticks);
348	
349	        Vec3 dir = (dashDirFromPacket != null && dashDirFromPacket.lengthSqr() > 1e-6)
350	                ? dashDirFromPacket.normalize()
351	                : new Vec3(0, 0, 1);
352	
353	        this.boostDir = dir;
354	        this.boostTicks = ticks;
355	        this.targetFwdSpeed = speed;
356	        this.boostStep = dir.scale(speed);
357	
358	        // Seed delta so clients interpolate the first tick
359	        this.setDeltaMovement(this.boostStep);
360	        this.hasImpulse = true;
361	
362	        this.fallDistance = 0f;
363	        this.jumpCooldown = JUMP_COOLDOWN_TICKS;
364	
365	        level().playSound(null, this.blockPosition(),
366	                SoundEvents.BEACON_ACTIVATE, SoundSource.PLAYERS, 0.9f, 1.0f);
367	
368	        // no debug chat
369	
370	        // no server-side beam
371	
372	        // Do not alter physics or eject the pilot; keep default riding behavior during burn
373	    }
374	
375	    // Movement
376	    @Override
377	    public void travel(Vec3 travelVector) {
378	        // Apply burn movement first, regardless of rider presence
379	        if (boostTicks > 0) {
380	            Vec3 step = this.boostStep;
381	            double spd = step.length();
382	            if (spd > ABS_SPEED_CAP) step = step.scale(ABS_SPEED_CAP / spd);
383	
384	            // Move using standard movement to avoid teleport-like behavior
385	            this.setDeltaMovement(step);
386	            this.hasImpulse = true;
387	            this.move(MoverType.SELF, this.getDeltaMovement());
388	            this.setOnGround(false);
389	            this.fallDistance = 0;
390	            boostTicks--;
391	            return;
392	        }
393	
394	        LivingEntity rider = this.getControllingPassenger();
395	        final double time = (this.tickCount + this.wobblePhase);
396	
397	        net.minecraft.server.level.ServerPlayer pilot = getPilot();
398	        if (!level().isClientSide && pilot != null && this.boostTicks <= 0 && (this.tickCount % 10 == 0)) {
399	            // Refresh any explicitly paired followers so they stay in formation
400	            assignTriangleFormation();
401	        }
402	        if (pilot != null) {
403	            this.setYRot(pilotYaw);
404	            this.setXRot(pilotPitch * 0.5F);
405	
406	            // Update lastDashDir from input (steer between dashes)
407	            // Flip strafe axis so D moves right and A moves left in world space
408	            double strafe = -pilotStrafe;
409	            double forward = pilotForward;
410	            float speedAttr = (float) this.getAttributeValue(Attributes.MOVEMENT_SPEED);
411	            Vec3 moveLocal = new Vec3(strafe, 0, forward);
412	            Vec3 moveWorld = moveLocal.yRot((float) Math.toRadians(-this.getYRot()));
413	            if (moveWorld.lengthSqr() > 0.0004) lastDashDir = moveWorld.normalize();
414	
415	            // (burn handled above)
416	
417	            // Not burning: gentle drag + standard hover + WASD blend
418	            Vec3 v = this.getDeltaMovement().scale(POST_BURN_DRAG);
419	
420	            double measuredGround = groundYAt(this.getX(), this.getZ());
421	            if (Double.isNaN(filteredGroundY)) filteredGroundY = measuredGround;
422	            double diff = measuredGround - filteredGroundY;
423	            double maxStep = 0.35; // limit ground height change per tick to smooth elevation rises
424	            if (diff > maxStep) diff = maxStep;
425	            else if (diff < -maxStep) diff = -maxStep;
426	            filteredGroundY += diff;
427	            double ground = filteredGroundY;
428	            double offset = pilotSneak ? 4.0 : HOVER_OFFSET_RIDDEN;
429	            double targetY = ground + offset;
430	            double vy = v.y;
