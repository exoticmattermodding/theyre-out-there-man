1	package com.exoticmatter.totm.world.entity.ai.goal;
2	
3	import com.exoticmatter.totm.world.entity.GrayAlienEntity;
4	import net.minecraft.util.Mth;
5	import net.minecraft.world.entity.ai.goal.Goal;
6	import net.minecraft.world.entity.player.Player;
7	import net.minecraft.world.level.ClipContext;
8	import net.minecraft.world.level.Level;
9	import net.minecraft.world.phys.HitResult;
10	import net.minecraft.world.phys.Vec3;
11	import net.minecraft.core.BlockPos;
12	import net.minecraft.world.level.pathfinder.Path;
13	
14	import java.util.EnumSet;
15	
16	public class GrayAlienHideFromGazeGoal extends Goal {
17	    private final GrayAlienEntity alien;
18	    private final double speedModifier;
19	    private final double triggerRange;
20	
21	    private Player watcher;
22	    private Vec3 targetPos;
23	    private int recalcCooldown;
24	    private boolean hidingMode; // true = hide fully; false = peek while keeping LoS
25	    private double prevDist;
26	
27	    // Cosine thresholds for "looking" and "crosshair on"
28	    private static final double LOOK_COS_THRESHOLD = 0.96;   // ~16 degrees
29	    private static final double AIM_COS_THRESHOLD  = 0.995;  // ~5 degrees ("crosshair on")
30	
31	    public GrayAlienHideFromGazeGoal(GrayAlienEntity alien, double speedModifier, double triggerRange) {
32	        this.alien = alien;
33	        this.speedModifier = speedModifier;
34	        this.triggerRange = triggerRange;
35	        this.setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK));
36	    }
37	
38	    @Override
39	    public boolean canUse() {
40	        if (alien.isNoAi() || alien.isDeadOrDying()) return false;
41	        Player nearest = alien.level().getNearestPlayer(alien, triggerRange);
42	        if (nearest == null) return false;
43	        if (!nearest.hasLineOfSight(alien)) return false;
44	
45	        Vec3 toAlien = alien.getEyePosition().subtract(nearest.getEyePosition()).normalize();
46	        double dot = nearest.getLookAngle().normalize().dot(toAlien);
47	        if (dot < LOOK_COS_THRESHOLD) return false;
48	
49	        // Decide if we must hide urgently or can peek
50	        this.hidingMode = dot >= AIM_COS_THRESHOLD;
51	        Vec3 found = this.hidingMode ? findHidePosition(nearest) : findPeekPosition(nearest);
52	        if (found == null) {
53	            // fallback: try the other mode before giving up
54	            found = this.hidingMode ? findPeekPosition(nearest) : findHidePosition(nearest);
55	        }
56	        if (found == null) return false;
57	
58	        this.watcher = nearest;
59	        this.targetPos = found;
60	        this.prevDist = alien.distanceTo(nearest);
61	        return true;
62	    }
63	
64	    @Override
65	    public void start() {
66	        if (targetPos != null) {
67	            this.alien.getNavigation().moveTo(targetPos.x, targetPos.y, targetPos.z, this.speedModifier);
68	        }
69	        this.recalcCooldown = 0;
70	    }
71	
72	    @Override
73	    public boolean canContinueToUse() {
74	        if (watcher == null) return false;
75	        if (!watcher.isAlive()) return false;
76	        if (alien.distanceToSqr(watcher) > (triggerRange * triggerRange)) return false;
77	
78	        // Recompute attention
79	        Vec3 toAlien = alien.getEyePosition().subtract(watcher.getEyePosition()).normalize();
80	        double dot = watcher.getLookAngle().normalize().dot(toAlien);
81	        if (dot < LOOK_COS_THRESHOLD && this.alien.getNavigation().isDone()) return false;
82	        if (this.hidingMode && !watcher.hasLineOfSight(alien) && this.alien.getNavigation().isDone()) return false; // already hidden successfully
83	
84	        return true;
85	    }
86	
87	    @Override
88	    public void tick() {
89	        if (watcher == null) return;
90	
91	        // Update mode based on current aim
92	        boolean urgent = isAimingAtMe(watcher);
93	        this.hidingMode = urgent;
94	
95	        if (urgent || --recalcCooldown <= 0) {
96	            recalcCooldown = urgent ? 5 : 20; // refresh more often when aimed at
97	            Vec3 newPos = this.hidingMode ? findHidePosition(watcher) : findPeekPosition(watcher);
98	            if (newPos != null) {
99	                targetPos = newPos;
100	                this.alien.getNavigation().moveTo(targetPos.x, targetPos.y, targetPos.z, urgent ? this.speedModifier * 1.25D : this.speedModifier);
101	            }
102	        }
103	
104	        // Peek behavior: look at the player only when not in hiding mode
105	        if (!this.hidingMode) {
106	            this.alien.getLookControl().setLookAt(watcher, 30.0f, 30.0f);
107	        }
108	
109	        // If the player is approaching, increase urgency/speed even when peeking
110	        double d = alien.distanceTo(watcher);
111	        boolean approaching = d < prevDist - 0.2;
112	        prevDist = d;
113	        if (!this.hidingMode && approaching) {
114	            this.alien.getNavigation().setSpeedModifier(this.speedModifier * 1.35D);
115	        }
116	    }
117	
118	    @Override
119	    public void stop() {
120	        this.watcher = null;
121	        this.targetPos = null;
122	    }
123	
124	    private boolean isAimingAtMe(Player player) {
125	        if (!player.hasLineOfSight(alien)) return false;
126	        Vec3 toAlien = alien.getEyePosition().subtract(player.getEyePosition()).normalize();
127	        double dot = player.getLookAngle().normalize().dot(toAlien);
128	        return dot >= AIM_COS_THRESHOLD;
129	    }
130	
131	    private Vec3 findHidePosition(Player player) {
132	        Level level = alien.level();
133	
134	        Vec3 playerToAlien = new Vec3(
135	                alien.getX() - player.getX(),
136	                0.0,
137	                alien.getZ() - player.getZ()
138	        ).normalize();
139	        if (playerToAlien.lengthSqr() < 1.0e-4) {
140	            playerToAlien = new Vec3(1, 0, 0);
141	        }
142	        Vec3 perpLeft = new Vec3(-playerToAlien.z, 0, playerToAlien.x);
143	        Vec3 perpRight = perpLeft.scale(-1);
144	
145	        // Try a handful of candidate offsets: behind and sidesteps, increasing radius
146	        double[] radii = new double[] { 3.0, 4.5, 6.0 };
147	        Vec3[] basis = new Vec3[] { playerToAlien, perpLeft, perpRight };
148	
149	        for (double r : radii) {
150	            for (Vec3 b : basis) {
151	                // Try center and slight side offsets to use natural cover
152	                Vec3[] offsets = new Vec3[] {
153	                        b.scale(r),
154	                        b.scale(r).add(perpLeft.scale(1.5)),
155	                        b.scale(r).add(perpRight.scale(1.5))
156	                };
157	                for (Vec3 off : offsets) {
158	                    Vec3 candidate = new Vec3(
159	                            alien.getX() + off.x,
160	                            floorToWalkableY(alien.getBlockY()),
161	                            alien.getZ() + off.z
162	                    );
163	                    if (!isReachable(candidate)) continue;
164	                    if (isLineOfSightBlocked(player, candidate)) {
165	                        return candidate;
166	                    }
167	                }
168	            }
169	        }
170	
171	        // Fallback: just move away from the player; may not block LoS but creates distance
172	        Vec3 fallback = new Vec3(
173	                alien.getX() + playerToAlien.x * 6.0,
174	                floorToWalkableY(alien.getBlockY()),
175	                alien.getZ() + playerToAlien.z * 6.0
176	        );
177	        return isReachable(fallback) ? fallback : null;
178	    }
179	
180	    private Vec3 findPeekPosition(Player player) {
181	        // Try to find a reachable position near an occluding block edge that still keeps LoS to the player.
182	        Vec3 dirToPlayer = new Vec3(
183	                player.getX() - alien.getX(),
184	                0.0,
185	                player.getZ() - alien.getZ()
186	        ).normalize();
187	        if (dirToPlayer.lengthSqr() < 1.0e-4) dirToPlayer = new Vec3(1, 0, 0);
188	        Vec3 perpLeft = new Vec3(-dirToPlayer.z, 0, dirToPlayer.x);
189	        Vec3 perpRight = perpLeft.scale(-1);
190	
191	        double[] radii = new double[] { 2.0, 3.0, 4.0 };
192	        Vec3[] laterals = new Vec3[] { perpLeft, perpRight };
193	
194	        for (double r : radii) {
195	            for (Vec3 lateral : laterals) {
196	                Vec3 off = lateral.scale(r * 0.8).add(dirToPlayer.scale(-0.5)); // hug cover slightly behind the edge
197	                Vec3 candidate = new Vec3(
198	                        alien.getX() + off.x,
199	                        floorToWalkableY(alien.getBlockY()),
200	                        alien.getZ() + off.z
201	                );
202	                if (!isReachable(candidate)) continue;
203	
204	                // Must have LoS to player to maintain eye contact
205	                if (isLineOfSightBlocked(player, candidate)) continue;
206	
207	                // Check that stepping a bit back is blocked (indicating a corner/edge to peek from)
208	                Vec3 tucked = candidate.add(dirToPlayer.scale(-0.8));
209	                if (!isLineOfSightBlocked(player, tucked)) continue;
210	
211	                // Also ensure there is a solid block near the tucked side to act as cover
212	                BlockPos coverPos = BlockPos.containing(candidate.add(dirToPlayer.scale(-1.0)));
213	                if (!alien.level().getBlockState(coverPos).isSolidRender(alien.level(), coverPos)) continue;
214	
215	                return candidate;
216	            }
217	        }
218	
219	        return null;
220	    }
221	
222	    private boolean isReachable(Vec3 target) {
223	        Path path = this.alien.getNavigation().createPath(BlockPos.containing(target), 0);
224	        return path != null;
225	    }
226	
227	    private boolean isLineOfSightBlocked(Player player, Vec3 target) {
228	        Level level = alien.level();
229	        Vec3 start = player.getEyePosition();
230	        Vec3 end = new Vec3(target.x, target.y + alien.getEyeHeight(alien.getPose()), target.z);
231	        HitResult res = level.clip(new ClipContext(start, end, ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE, player));
232	        return res.getType() == HitResult.Type.BLOCK;
233	    }
234	
235	    private double floorToWalkableY(int y) {
236	        // Keep Y stable with a slight bias downward to favor ground paths
237	        return Mth.floor(y);
238	    }
239	}
